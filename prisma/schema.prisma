generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String         @id @default(uuid())
  email               String         @unique
  role                String         @default("user")
  phone               String?
  profile_picture     String?
  verification_status String         @default("pending")
  seller_badge        Boolean        @default(false)
  avg_rating          Float          @default(0.0)
  rating_count        Int            @default(0)
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  full_name           String?
  active              Boolean        @default(true)
  googleId            String?        @unique
  provider            String?        @default("local")
  otps                Otp[]
  password            Password?
  products            Product[]
  offers              Offer[]
  buyerTransactions   Transaction[]  @relation("BuyerTransactions")
  sellerTransactions  Transaction[]  @relation("SellerTransactions")
  transactions        Transaction[]
  notifications       Notification[]
}

model Password {
  hash   String
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  email     String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

model Otp {
  id          Int       @id @default(autoincrement())
  selector    String    @unique
  code        String?
  codeHash    String
  type        String
  channel     String?   @default("EMAIL")
  userId      String?
  email       String?
  attempts    Int       @default(0)
  maxAttempts Int?
  used        Boolean   @default(false)
  consumedAt  DateTime?
  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  User        User?     @relation(fields: [userId], references: [id])

  @@index([email, type, expiresAt])
  @@index([userId, type, expiresAt])
}

model Product {
  id            String        @id @default(uuid())
  title         String
  description   String
  price         Float
  urgencyEndsAt DateTime?
  imageUrls     String[]
  country       String
  state         String
  city          String
  street        String
  status        ProductStatus @default(PENDING)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  categoryId    String
  userId        String
  category      Category      @relation(fields: [categoryId], references: [id])
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  offers        Offer[]
  Transaction   Transaction[]
}

model Category {
  id            String    @id @default(uuid())
  name          String
  percentageFee Float
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  products      Product[]
}

model Offer {
  id            String        @id @default(uuid())
  productId     String
  userId        String
  status        OfferStatus   @default(PENDING)
  counterAmount Decimal
  createdAt     DateTime      @default(now())
  respondedAt   DateTime?
  product       Product       @relation(fields: [productId], references: [id])
  user          User          @relation(fields: [userId], references: [id])
  transactions  Transaction[]
}

model Transaction {
  id        String   @id @default(uuid())
  productId String
  buyerId   String
  sellerId  String
  offerId   String?
  amount    Decimal
  createdAt DateTime @default(now())
  product   Product  @relation(fields: [productId], references: [id])
  buyer     User     @relation("BuyerTransactions", fields: [buyerId], references: [id])
  seller    User     @relation("SellerTransactions", fields: [sellerId], references: [id])
  offer     Offer?   @relation(fields: [offerId], references: [id])
  User      User?    @relation(fields: [userId], references: [id])
  userId    String?
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType
  message   String
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id])
}

enum OfferStatus {
  PENDING
  APPROVED
  REJECTED
  WITHDRAWN
}

enum ProductStatus {
  PENDING
  ACTIVE
  INACTIVE
  EXPIRED
}

enum NotificationType {
  IN_APP
  EMAIL
}
